// <copyright file="FilteredEnumerable.cs" company="Jack Badger Ltd">
// Copyright (c) Jack Badger Ltd. All rights reserved.
// </copyright>

namespace JBLib
{
    using System;
    using System.Collections.Generic;
    using System.Linq;

    public enum FilterOption
    {
        Ignore,
        Select,
    }

    public class FilteredEnumerable<TKey, TItem>
    {
        private readonly IDictionary<TKey, IList<TItem>> dic = new Dictionary<TKey, IList<TItem>>();

        /// <summary>
        /// The key generator used to group items.
        /// </summary>
        /// <autogeneratedoc />
        /// TODO Edit XML Comment Template for keyGenerator
        private readonly Func<TItem, TKey> keyGenerator;

        internal void Clear() => dic.Clear();

        /// <summary>
        /// Initializes a new instance of the <see cref="FilteredEnumerable{TKey, TItem}"/> class.
        /// </summary>
        /// <param name="keyGenerator">The key generator.</param>
        /// <autogeneratedoc />
        public FilteredEnumerable(Func<TItem, TKey> keyGenerator)
        {
            this.keyGenerator = keyGenerator;
        }

        /// <summary>
        /// Gets or sets the behaviour.
        /// </summary>
        /// <autogeneratedoc />
        public FilterOption Behaviour { get; set; } = FilterOption.Ignore;

        /// <summary>
        /// Gets or sets the filters.
        /// </summary>
        /// <autogeneratedoc />
        public ISet<TKey> FilterSet { get; set; } = new HashSet<TKey>();

        /// <summary>
        /// Gets the total item count.
        /// </summary>
        /// <autogeneratedoc />
        public int TotalItemCount { get; private set; }

        public IEnumerable<TKey> Keys => dic.Keys;

        /// <summary>
        /// Gets the <see cref="IEnumerable{TItem}"/> with the specified key.
        /// </summary>
        /// <param name="key">The key.</param>
        /// <returns>The Items that have been added.</returns>
        /// <autogeneratedoc />
        public IEnumerable<TItem> this[TKey key]
            => dic.TryGetValue(key, out var list) ? list : Enumerable.Empty<TItem>();

        /// <summary>
        /// Adds and groups items as per the <see cref="keyGenerator"/>.
        /// Subject to <see cref="Behaviour"/>
        /// and <see cref="FilterSet"/>.
        /// </summary>
        /// <param name="items">The items.</param>
        /// <returns>The number of items added.</returns>
        /// <autogeneratedoc />
        public int AddRange(IEnumerable<TItem> items)
        {
            int count = 0;

            foreach (var item in items)
            {
                var key = keyGenerator(item);

                // i - ignore (select = not ignore)
                // c - contains
                //
                // i c
                // 0 0 | 0   select/not contains => false
                // 0 1 | 1   select/contains => true
                // 1 0 | 1   ignore/not contains => true
                // 1 1 | 0   ignore/contains => false
                //
                // XOR
                //
                if ((Behaviour == FilterOption.Ignore) ^ FilterSet.Contains(key))
                {
                    if (!dic.ContainsKey(key))
                    {
                        dic.Add(key, new List<TItem>());
                    }

                    dic[key].Add(item);
                    count += 1;
                }
            }

            TotalItemCount += count;

            return count;
        }
    }
}
